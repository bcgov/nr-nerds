{"chunk":25,"numChunks":31,"fileHash":"d/sfK61LpWfXclxI64CLwQIr+HeWHt3JRwU/EIB4ZQc=","filePath":"project-board-sync/src/utils/state-verifier.js","content":"/**\nclass StateVerifier {\n  static async verifyCompleteState(item, projectId, expectedState) {\n    const result = await this.retryWithTracking(\n      async (attempt) => {\n        try {\n          const currentState = {\n            inProject: true,\n            projectItemId: item.projectItemId,\n            column: await getItemColumn(projectId, item.projectItemId) || 'None',\n            sprint: (await getItemSprint(projectId, item.projectItemId))?.sprintId || 'None',\n            assignees: await getItemAssignees(projectId, item.projectItemId) || []\n          };\n          const afterState = this.updateState(item, currentState);\n          this.progress.recordApiTiming('getItemState', Date.now() - apiStart);\n          // Enhanced state verification with detailed error messages\n          const mismatches = [];\n          [ 'column', 'sprint', 'assignees' ].forEach(aspect => {\n            if (expectedState[ aspect ]) {\n              const success = this.verifyStateAspect(aspect, expectedState[ aspect ], afterState[ aspect ]);\n              this.progress.recordStep('Complete Verification', itemRef,\n                `Verify ${aspect}: ${JSON.stringify(expectedState[ aspect ])}`, success);\n\n              if (!success) {\n                const mismatchMessage = this.getStateAspectMismatchMessage(\n                  aspect,\n                  expectedState[ aspect ],\n                  afterState[ aspect ]\n                );\n                mismatches.push({\n                  aspect,\n                  message: mismatchMessage,\n                  recovery: this.getRecoverySteps(aspect, expectedState[ aspect ], afterState[ aspect ])\n                });\n              }\n            }\n          });\n          if (mismatches.length > 0) {\n            throw new StateVerifierError(\n              'State verification failed:\\n' +\n              mismatches.map(m => `  - ${m.message}`).join('\\n'),\n              {\n                itemType: item.type,\n                itemNumber: item.number,\n                isRetryable: true,\n                recoverySteps: mismatches.flatMap(m => m.recovery)\n              }\n           "}